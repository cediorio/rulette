{"version":3,"sources":["../src/graph.js"],"names":["Graph","constructor","name","_name","_adjList","_nodes","missingValuesStack","_log","logging","msg","log","value","nodeNames","Object","keys","createNode","args","n","Node","_addNode","nodes","getNodeByName","filter","node","getNodeChildren","adjList","push","addEdge","vertex1","vertex2","Error","dfs","visited","forEach","_dfsUtil","neighbours","i","neighbour","detectCycle","graphNodes","recStack","_detectCycleUtil","nodeNeighbours","currentNode","findGoalNodes","hasParentTestList","entries","children","child","nodesWithParents","Set","e","map","goalNodes","has","evalGoalNodes","goals","results","goal","evalRuleTree","c","result","_evalRTUtil","_reject","_accept","s","_checkIfUndefined","pushToMissingValues","includes","root","operator","nodeType","rootUndefValue","RHS","length","left","right","leftUndefValue","rightUndefValue","traverseNodesBFS","path","queue","_addToPathBFS","unshift","pop","takenNames","DuplicateNameError","_uniqueName","nodeTypes","_nodeType","valueTypes","_value","proposedName","_defaultName","randomWordLen","charNum","rMin","rMax","tMin","tMax","String","fromCharCode","parseInt","Math","random"],"mappings":"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","sourcesContent":["/* Nodes are of type 'op'{erator} or 'prop'{osition}\n */\n\nexport class Graph {\n    constructor( {name = ''} = {}) {\n\tthis._name = name;\n\tthis._adjList = {};\n\tthis._nodes = [];\n\tthis.missingValuesStack = [];\n\tthis._log = '';\n    }\n\n    logging( msg ) {\n\tthis._log += msg;\n    }\n\n    get log() {\n\treturn this._log;\n    }\n    \n    get name() {\n\treturn this._name;\n    }\n\n    set name(value) {\n\tthis._name = value;\n    }\n\n    get nodeNames() {\n\treturn Object.keys(this._adjList);\n    }\n    \n    createNode( args ) { // args =  = {name: <name>, nodeType: <nodeType>, value: <value>}\n\targs['nodeNames'] = this.nodeNames;\n\t// console.log(`from createNode: this.nodeNames = ${'test' in args.nodeNames}`);\n\tlet n = new Node(args);\n\t// console.log(`Node name: ${n.name}`);\n\tthis._addNode(n);\n\treturn n;\n    }\n\n    get nodes() {\n\treturn this._nodes;\n    }\n\n    getNodeByName(name) {\n\treturn this._nodes.filter(node => node.name === name)[0];\n    }\n\n    getNodeChildren(name) {\n\treturn this.adjList[name];\n    }\n    \n    _addNode(node) {\n\tthis._adjList[node.name] = [];\n\tthis._nodes.push( node );\n    }\n\n    addEdge( vertex1, vertex2 ) {\n    \tif ( typeof vertex1 !== 'undefined' && typeof vertex2 !== 'undefined' ) {\n\t    if ( typeof vertex1 === 'object' && typeof vertex2 === 'object' ) \n    \t\tthis._adjList[vertex1.name].push(vertex2.name);\n\t    if ( typeof vertex1 === 'string' && typeof vertex2 === 'string' ) \n    \t\tthis._adjList[vertex1].push(vertex2);\n    \t}\n    \telse {\n    \t    throw new Error(`addEdge requires two names of nodes/vertices to create an edge: addEdge was provided with:\n\t\t\t\tvertex1: ${vertex1}\n\t\t\t\tvertex2: ${vertex2}`);\n    \t}\n    }\n    \n    get adjList() {\n\treturn this._adjList;\n    }\n\n    dfs() {\n\tconst nodes = this.nodeNames;\n\tconst visited = {};\n\tnodes.forEach( node => {\n\t    this._dfsUtil( node, visited);\n\t});\n    }\n\n    _dfsUtil(node, visited) {\n\tif ( !visited[node] ) {\n\t    visited[node] = true;\n\t    const neighbours = this.adjList[node];\n\t    // console.log(`node: ${node}\\nvisited: ${visited[node]}\\nneighbours: ${neighbours}`);\n\t    if( typeof neighbours !== 'undefined' ) {\n\t\tneighbours.forEach( i => {\n\t    \t    const neighbour = neighbours[i];\n\t    \t    this._dfsUtil(neighbour, visited);\n\t\t});\n\t    }\n\t}\n    }\n\n    detectCycle() {\n\tconst graphNodes = this.nodeNames;\n\tconst visited = {};\n\tconst recStack = {};\n\n\tfor(let node of graphNodes) {\n\t    if (this._detectCycleUtil( node, visited, recStack))\n\t\treturn 'CYCLE EXISTS';\n\t}\n\n\treturn 'NO CYCLE EXISTS';\n    }\n\n    _detectCycleUtil(node, visited, recStack) {\n\tif ( !visited[node] ) {\n\t    visited[node] = true;\n\t    recStack[node] = true;\n\t    const nodeNeighbours = this.adjList[node];\n\t    if ( typeof nodeNeighbours !== 'undefined' ) {\n\t\tfor(let currentNode of nodeNeighbours) {\n\t\t    // console.log(`parent: ${node}, Child: ${currentNode}`);\n\t\t    if(!visited[currentNode] && this._detectCycleUtil(currentNode, visited, recStack)) {\n\t\t\treturn true;\n\t\t    } else if ( recStack[currentNode] ) {\n\t\t\treturn true;\n\t\t    }\n                }\n\t    }\n\t}\n\trecStack[node] = false;\n\treturn false;\n    }\n\n    findGoalNodes() {\n\tconst hasParentTestList = {};\n\tObject.entries(this.adjList).forEach( node => {\n\t    const children = node[1];\n\t    children.forEach( child => {\n\t\thasParentTestList[child] = true;\n\t    });\n\t});\n\tconst nodesWithParents = new Set(Object.entries(hasParentTestList).filter(e => e[1] === true ).map(e => e[0]));\n\t\n\tconst goalNodes = this.nodeNames.filter(e => !nodesWithParents.has(e));\n\treturn goalNodes;\n    }\n\n    evalGoalNodes( goals ) {\n\tlet results = {};\n\tfor ( let goal of goals ) {\n\t    this.missingValuesStack = []; // init to empty\n\t    results[goal] = this.evalRuleTree( goal );\n\t}\n\n\treturn results;\n    }\n    \n    evalRuleTree(c) {\n\t// _evalRTUtil will return an object with the truthiness of\n\t// the evaluated rule tree if it can reject or accept it and\n\t// the node that was evaluated -- otherwise, it returns an\n\t// array of the props it was unable to find values for\n\tconst visited = {};\t// note that this isn't currently set anywhere, but may become useful\n\t\t\t\t// in future to iterate where facts are solicited interactively\n\tconst result = this._evalRTUtil( c, visited );\n\treturn result;\n    }\n\n    _evalRTUtil( c, visited ) {\n\t/* Will return: (1) on success: the node that was successfully\n\t * evaluated; (2) on failure, an array containing the nodes\n\t * which are missing truth values. \n\t */\n\t\n\tif (typeof c === 'undefined') throw new Error( 'You must supply a root node to begin the backtracking search.' );\n\n\tif( this._reject( c ) )\n\t    return {\n\t\tresult: 'reject',\n\t\tnodes: this.missingValuesStack\n\t    };\n\n\tif ( this._accept(c) )\n\t    return {\n\t\tresult: 'accept',\n\t\tnodes: this.getNodeByName(c)\n\t    };\n\n\tconst children = this.adjList[c];\n\t\n\tfor ( let s of children) {\n\t    if( !visited[s] ) this._evalRTUtil(s, visited);\n\t}\n\n\tthrow new Error(`_evalRTUtil was unable to evaluate the rule tree provided:\n\t\t\t\trule tree root node: ${this.getNodeByName(c)}\n\t\t\t` );\n    }\n\n    _checkIfUndefined( c ) {\n\tconst node = this.getNodeByName(c);\n\tif ( node.value === null ) {\n\t    return true;\n\t} else return false;\n    }\n\n    pushToMissingValues (n) {\n\tif ( !( n instanceof Node ) ) throw new Error( \"usage: pushToMissingValues( <Node> )\" );\n\tif ( n.value === null ) {\n\t    if ( !this.missingValuesStack.includes(n.name) ) this.missingValuesStack.push(n.name);\n\t}\n    }\n    \n    _reject( c ) {\n\t// The reject procedure should return true only if the\n\t// candidate or its children that could evaluate to a truth\n\t// result are undefined, in which case return the list of\n\t// missing values\n\n\t// determine undefined status for root and children (depending\n\t// on operator type)\n\tconst root = this.getNodeByName(c);\n\tlet operator = root.nodeType;\n\tconst rootUndefValue = this._checkIfUndefined(c);\n\tconst children = this.adjList[c].map( e => this.getNodeByName(e) );\n\tconst RHS = operator === 'prop' && children.length > 0;\n\t// if the node is an RHS, then give it a special operator\n\toperator = RHS ? 'rhs' : operator; \n\tconst left = children[0];\n\tconst right = children[1];\n\tlet leftUndefValue = left ? this._checkIfUndefined(children[0].name) : null;\n\t// a node that is either a 'not' or an RHS will have no right child\n\tlet rightUndefValue = operator !== 'not' && !RHS && ( right ? this._checkIfUndefined(children[1].name) : null ); \n\n\tswitch ( operator ) {\n\tcase 'rhs':\n\tcase 'not':\n\t    leftUndefValue = leftUndefValue && \n\t\t( ( this.adjList[left.name].length > 0 ) ? this._reject(left.name) : true );\n\n\t    if ( rootUndefValue && leftUndefValue ) { // only one operand with 'not' \n\t\t[ root, left ].forEach( e => this.pushToMissingValues(e) );\n\t\treturn true;\n\t    }\n\t    break;\n\t    \n\tcase 'and':\n\t    leftUndefValue = leftUndefValue && \n\t\t( ( this.adjList[left.name].length > 0 ) ? this._reject(left.name) : true );\n\t    rightUndefValue = rightUndefValue &&\n\t\t( ( this.adjList[right.name].length > 0 ) ? this._reject(right.name) : true );\n\t    \n\t    if ( rootUndefValue && ( leftUndefValue || rightUndefValue ) ) {\n\t\t[ root, left, right ].forEach( e => this.pushToMissingValues(e) );\n   \t\treturn true;\n\t    }\n\t    break;\n\n\tcase 'or':\n\t    leftUndefValue = leftUndefValue && \n\t\t( ( this.adjList[left.name].length > 0 ) ? this._reject(left.name) : true );\n\t    rightUndefValue = rightUndefValue &&\n\t\t( ( this.adjList[right.name].length > 0 ) ? this._reject(right.name) : true );\n\n\t    if ( rootUndefValue && ( leftUndefValue && rightUndefValue  ) ) {\n\t\t[ root, left, right ].forEach( e => this.pushToMissingValues(e) );\n   \t\treturn true;\n\t    }\n\t    break;\n\t}\n\t\n\treturn false;\n    } // end _reject\n    \n    _accept(c) {\n\t/* The accept procedure should return true if c is a complete\n\t * and valid solution for the problem instance P, and false\n\t * otherwise. It may assume that the partial candidate c and\n\t * all its ancestors in the tree have passed the reject\n\t * test. */\n\tconst root = this.getNodeByName(c);\n\tconst children = this.adjList[root.name];\n\tlet operator = root.nodeType;\n\tconst RHS = operator === 'prop' && children.length > 0;\n\t// if the root is an RHS, then give it a special operator\n\toperator = RHS ? 'rhs' : operator; \n\tconst left = this.getNodeByName(children[0]);\n\tconst right = this.getNodeByName(children[1]);\n\t\t\t\n\t// return true if the root already has a value\n\tif ( root.value !== null ) return true;\n\n\t// different tests for different operators, obviously\n\n\tswitch ( operator ) {\n\tcase 'rhs':\n\t    if ( left.value !== null ) {\n\t\troot.value = left.value;\n\t\treturn true;\n\t    } else if ( this._accept( left.name ) ) {\n\t\troot.value = left.value;\n\t\treturn true;\n\t    }\n\t    break;\n\tcase 'not':\n\t    if ( left.value === null ) this._accept( left.name );\n\t    root.value = left.value ? false : true;\n\t    return true;\n\t    break;\n\n\tcase 'or':\n\t    if ( left.value === null ) this._accept( left.name );\n\t    if ( right.value === null ) this._accept( right.name );\n\n\t    root.value = left.value || right.value;\n\t    return true;\n\t    break;\n\n\tcase 'and':\n\t    if ( left.value === null ) this._accept( left.name );\n\t    if ( right.value === null ) this._accept( right.name );\n\n\t    root.value = left.value && right.value;\n\t    return true;\n\t    break;\n\t}\n\treturn false;\n\n    } // end _accept\n\n    traverseNodesBFS(c) {\n\t// the path of left and right nodes all the way to the bottom\n\t// of the tree, by breadth\n\n\tlet path = [];\n\tlet queue = [c];\n\tconst _addToPathBFS = c => {\n\t    let node = this.getNodeByName(c);\n\t    \n\t    // if the node is a not, sub in its operand, which is the\n\t    // first entry in the adjList for that node\n\t    if ( node.nodeType === 'not' )\n\t\tc = this.adjList[node.name][0];\n\t    if ( this.getNodeByName(c).nodeType === 'prop' )\n\t\tpath.push(c);\n\t    for ( let i of this.adjList[c] ) \n\t\tqueue.unshift(i);\n\t};\n\t\n\n\twhile ( queue.length > 0 ) {\n\t    _addToPathBFS( queue.pop(), path );\n\t}\n\n\treturn path;\n    }\n\n    _addToPathBFS(c) {\n\tpath.push(c);\n\t\n    }\n}\n\nexport class Node {\n    constructor( {name = null, nodeType = 'prop', value = null, nodeNames = []} = {})  {\n\t// let {name, nodeType, value, nodeNames} = args;\n\n\tthis.name = {name: name, nodeType: nodeType, takenNames: nodeNames};\n\tthis.nodeType = nodeType;\n\tthis.value = value;\n    }\n\n    // has to be a props object with {name: <name>, nodeType: <nodeType>, takenNames: <names \n    // that are not available>}\n    set name( {name = null, nodeType = null, takenNames = [] } = {} ) {\n\n\t// throw if name is already in the graph\n\tif ( takenNames && takenNames.includes(name) ) throw new DuplicateNameError( `Node name ${name} has already been used in this graph instance.`);\n\t// generate a unique name if a unique name isn't provided\n\tif ( name  ) this._name = name;\n\telse {\n\t    this._name = _uniqueName(nodeType, takenNames);\n\t}\n    }\n\n    get name() {\n\treturn this._name;\n    }\n    \n    set nodeType(nodeType) {\n\t// enforce use one of the permissible nodeTypes (defaults to 'prop' when no args are provided)\n\tconst nodeTypes = ['prop', 'and', 'or', 'not'];\n\tif ( nodeTypes.includes(nodeType) ) \n\t    this._nodeType = nodeType;\n\telse if ( typeof nodeType !== 'undefined' ) \n\t    throw new Error(`nodeType must be one of ${nodeTypes}`);\n\telse this._nodeType = 'prop';\n    }\n\n    get nodeType() {\n\treturn this._nodeType;\n    }\n\n    // enforces use of set valueTypes\n    set value(value) {\n\tconst valueTypes = [ true, false, 'true', 'false' ]; // values may be received as strings\n\tif ( valueTypes.includes(value) ) {\n\t    if ( value === 'true' ) value = true;\n\t    if ( value === 'false' ) value = false;\n\t    this._value = value;\n\t} else if ( value !== null && typeof value !== 'undefined' && !valueTypes.includes(value) ) {\n\t    throw new Error(`value must be one of ${valueTypes}`);\n\t} else this._value = null;\n    }\n\n    get value() {\n\treturn this._value;\n    }\n}\n\nconst _uniqueName = ( nodeType, takenNames ) => {\n    let proposedName = _defaultName( nodeType );\n    if ( typeof takenNames === 'undefined' || takenNames.length < 1 ) return proposedName;\n    else if ( proposedName in takenNames ) _uniqueName( takenNames );\n    else return proposedName;\n};\n\nconst _defaultName = ( nodeType ) => {\n    // get a random char number between 65 to 122\n    // thx to https://stats.stackexchange.com/questions/281162/scale-a-number-between-a-range\n    let randomWordLen = 10;\n    let charNum = (e) => {\n\tconst rMin = 0, rMax = 1, tMin = 97, tMax = 122; // 97 to 122 is 'a' to 'z'\n\treturn String.fromCharCode( parseInt( ((e - rMin)/(rMax - rMin)) * (tMax - tMin) + tMin ) );\n    };\n    var name = '';\n    for(let i=0; i < randomWordLen; i++) {\n\tname += charNum(Math.random());\n    }\n\n    name = nodeType + '_' + name;\n\n    return name;\n};\n\nexport class DuplicateNameError extends Error {\n    constructor( msg ) {\n\tsuper( msg );\n\tthis.name = 'DuplicateNameError';\n    }\n\n}\n"],"file":"graph.js"}