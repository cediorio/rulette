{"version":3,"sources":["../src/graph.js"],"names":["Graph","constructor","name","_name","_adjList","_nodes","missingValuesStack","value","nodeNames","Object","keys","createNode","args","n","Node","_addNode","nodes","getNodeByName","filter","node","getNodeChildren","adjList","push","addEdge","vertex1","vertex2","Error","dfs","visited","forEach","_dfsUtil","neighbours","i","neighbour","detectCycle","graphNodes","recStack","_detectCycleUtil","nodeNeighbours","currentNode","findGoalNodes","hasParentTestList","entries","children","child","nodesWithParents","Set","e","map","goalNodes","has","evalGoalNodes","goals","results","goal","evalRuleTree","c","result","_evalRTUtil","_reject","_accept","s","_checkIfUndefined","root","operator","nodeType","rootUndefValue","RHS","length","left","right","leftUndefValue","rightUndefValue","pushToMissingValues","includes","takenNames","_uniqueName","nodeTypes","_nodeType","valueTypes","_value","proposedName","_defaultName","randomWordLen","charNum","rMin","rMax","tMin","tMax","String","fromCharCode","parseInt","Math","random"],"mappings":"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","sourcesContent":["/* Nodes are of type 'op'{erator} or 'prop'{osition}\n */\nexport class Graph {\n    constructor( {name = ''} = {}) {\n\tthis._name = name;\n\tthis._adjList = {};\n\tthis._nodes = [];\n\tthis.missingValuesStack = [];\n    }\n\n    get name() {\n\treturn this._name;\n    }\n\n    set name(value) {\n\tthis._name = value;\n    }\n\n    get nodeNames() {\n\treturn Object.keys(this._adjList);\n    }\n    \n    createNode( args ) { // args =  = {name: <name>, nodeType: <nodeType>, value: <value>}\n\targs['nodeNames'] = this.nodeNames;\n\t// console.log(`from createNode: this.nodeNames = ${'test' in args.nodeNames}`);\n\tlet n = new Node(args);\n\tthis._addNode(n);\n\treturn n;\n    }\n\n    get nodes() {\n\treturn this._nodes;\n    }\n\n    getNodeByName(name) {\n\treturn this._nodes.filter(node => node.name === name)[0];\n    }\n\n    getNodeChildren(name) {\n\treturn this.adjList[name];\n    }\n    \n    _addNode(node) {\n\tthis._adjList[node.name] = [];\n\tthis._nodes.push( node );\n    }\n\n    addEdge( vertex1, vertex2 ) {\n    \tif ( typeof vertex1 !== 'undefined' && typeof vertex2 !== 'undefined' ) {\n\t    if ( typeof vertex1 === 'object' && typeof vertex2 === 'object' ) \n    \t\tthis._adjList[vertex1.name].push(vertex2.name);\n\t    if ( typeof vertex1 === 'string' && typeof vertex2 === 'string' ) \n    \t\tthis._adjList[vertex1].push(vertex2);\n    \t}\n    \telse {\n    \t    throw new Error(\"addEdge requires two names of nodes/vertices to create an edge\");\n    \t}\n    }\n    \n    get adjList() {\n\treturn this._adjList;\n    }\n\n    dfs() {\n\tconst nodes = this.nodeNames;\n\tconst visited = {};\n\tnodes.forEach( node => {\n\t    this._dfsUtil( node, visited);\n\t});\n    }\n\n    _dfsUtil(node, visited) {\n\tif ( !visited[node] ) {\n\t    visited[node] = true;\n\t    const neighbours = this.adjList[node];\n\t    // console.log(`node: ${node}\\nvisited: ${visited[node]}\\nneighbours: ${neighbours}`);\n\t    if( typeof neighbours !== 'undefined' ) {\n\t\tneighbours.forEach( i => {\n\t    \t    const neighbour = neighbours[i];\n\t    \t    this._dfsUtil(neighbour, visited);\n\t\t});\n\t    }\n\t}\n    }\n\n    detectCycle() {\n\tconst graphNodes = this.nodeNames;\n\tconst visited = {};\n\tconst recStack = {};\n\n\tfor(let node of graphNodes) {\n\t    if (this._detectCycleUtil( node, visited, recStack))\n\t\treturn 'CYCLE EXISTS';\n\t}\n\n\treturn 'NO CYCLE EXISTS';\n    }\n\n    _detectCycleUtil(node, visited, recStack) {\n\tif ( !visited[node] ) {\n\t    visited[node] = true;\n\t    recStack[node] = true;\n\t    const nodeNeighbours = this.adjList[node];\n\t    if ( typeof nodeNeighbours !== 'undefined' ) {\n\t\tfor(let currentNode of nodeNeighbours) {\n\t\t    // console.log(`parent: ${node}, Child: ${currentNode}`);\n\t\t    if(!visited[currentNode] && this._detectCycleUtil(currentNode, visited, recStack)) {\n\t\t\treturn true;\n\t\t    } else if ( recStack[currentNode] ) {\n\t\t\treturn true;\n\t\t    }\n                }\n\t    }\n\t}\n\trecStack[node] = false;\n\treturn false;\n    }\n\n    findGoalNodes() {\n\tconst hasParentTestList = {};\n\tObject.entries(this.adjList).forEach( node => {\n\t    const children = node[1];\n\t    children.forEach( child => {\n\t\thasParentTestList[child] = true;\n\t    });\n\t});\n\tconst nodesWithParents = new Set(Object.entries(hasParentTestList).filter(e => e[1] === true ).map(e => e[0]));\n\t\n\tconst goalNodes = this.nodeNames.filter(e => !nodesWithParents.has(e));\n\treturn goalNodes;\n    }\n\n    evalGoalNodes( goals ) {\n\tlet results = {};\n\tfor ( let goal of goals ) {\n\t    results[goal] = this.evalRuleTree( goal );\n\t}\n\n\treturn results;\n    }\n    \n    evalRuleTree(c) {\n\t// _evalRTUtil will return an object with the truthiness of\n\t// the evaluated rule tree if it can reject or accept it and\n\t// the node that was evaluated -- otherwise, it returns an\n\t// array of the props it was unable to find values for\n\tconst visited = {};\t// note that this isn't currently set anywhere, but may become useful\n\t\t\t\t// in future to iterate where facts are solicited interactively\n\tconst result = this._evalRTUtil( c, visited );\n\treturn result;\n    }\n\n    _evalRTUtil( c, visited ) {\n\t/* Will return: (1) on success: the node that was successfully\n\t * evaluated; (2) on failure, an array containing the nodes\n\t * which are missing truth values. \n\t */\n\t\n\tif (typeof c === 'undefined') throw new Error( 'You must supply a root node to begin the backtracking search.' );\n\n\tif( this._reject( c ) )\n\t    return {\n\t\tresult: 'reject',\n\t\tnodes: this.missingValuesStack\n\t    };\n\n\tif ( this._accept(c) )\n\t    return {\n\t\tresult: 'accept',\n\t\tnodes: this.getNodeByName(c)\n\t    };\n\n\tconst children = this.adjList[c];\n\t\n\tfor ( let s of children) {\n\t    if( !visited[s] ) this._evalRTUtil(s, visited);\n\t}\n\n\tthrow new Error(`_evalRTUtil was unable to evaluate the rule tree provided:\n\t\t\t\trule tree root node: ${this.getNodeByName(c)}\n\t\t\t` );\n    }\n\n    _checkIfUndefined( c ) {\n\tconst node = this.getNodeByName(c);\n\tif ( node.value === null ) {\n\t    return true;\n\t} else return false;\n    }\n\n    _reject( c ) {\n\t// The reject procedure should return true only if the\n\t// candidate or its children that could evaluate to a truth\n\t// result are undefined, in which case return the list of\n\t// missing values\n\n\t// determine undefined status for root and children (depending\n\t// on operator type)\n\tconst root = this.getNodeByName(c);\n\tlet operator = root.nodeType;\n\tconst rootUndefValue = this._checkIfUndefined(c);\n\tconst children = this.adjList[c].map( e => this.getNodeByName(e) );\n\tconst RHS = operator === 'prop' && children.length > 0;\n\t// if the node is an RHS, then give it a special operator\n\toperator = RHS ? 'rhs' : operator; \n\tconst left = children[0];\n\tconst right = children[1];\n\tlet leftUndefValue = left ? this._checkIfUndefined(children[0].name) : null;\n\t// a node that is either a 'not' or an RHS will have no right child\n\tlet rightUndefValue = operator !== 'not' && !RHS && ( right ? this._checkIfUndefined(children[1].name) : null ); \n\n\tconst pushToMissingValues = (n) => {\n\t    if ( !( n instanceof Node ) ) throw new Error( \"usage: pushToMissingValues( <Node> )\" );\n\t    if ( n.value === null ) {\n\t\tif ( !this.missingValuesStack.includes(n.name) ) this.missingValuesStack.push(n.name);\n\t    }\n\t};\n\t\n\tswitch ( operator ) {\n\tcase 'rhs':\n\tcase 'not':\n\t    leftUndefValue = leftUndefValue && \n\t\t( ( this.adjList[left.name].length > 0 ) ? this._reject(left.name) : true );\n\n\t    if ( rootUndefValue && leftUndefValue ) { // only one operand with 'not' \n\t\t[ root, left ].forEach( e => pushToMissingValues(e) );\n\t\treturn true;\n\t    }\n\t    break;\n\t    \n\tcase 'and':\n\t    leftUndefValue = leftUndefValue && \n\t\t( ( this.adjList[left.name].length > 0 ) ? this._reject(left.name) : true );\n\t    rightUndefValue = rightUndefValue &&\n\t\t( ( this.adjList[right.name].length > 0 ) ? this._reject(right.name) : true );\n\t    \n\t    if ( rootUndefValue && ( leftUndefValue || rightUndefValue ) ) {\n\t\t[ root, left, right ].forEach( e => pushToMissingValues(e) );\n   \t\treturn true;\n\t    }\n\t    break;\n\n\tcase 'or':\n\t    leftUndefValue = leftUndefValue && \n\t\t( ( this.adjList[left.name].length > 0 ) ? this._reject(left.name) : true );\n\t    rightUndefValue = rightUndefValue &&\n\t\t( ( this.adjList[right.name].length > 0 ) ? this._reject(right.name) : true );\n\n\t    if ( rootUndefValue && ( leftUndefValue && rightUndefValue  ) ) {\n\t\t[ root, left, right ].forEach( e => pushToMissingValues(e) );\n   \t\treturn true;\n\t    }\n\t    break;\n\t}\n\t\n\treturn false;\n    } // end _reject\n    \n    _accept(c) {\n\t/* The accept procedure should return true if c is a complete\n\t * and valid solution for the problem instance P, and false\n\t * otherwise. It may assume that the partial candidate c and\n\t * all its ancestors in the tree have passed the reject\n\t * test. */\n\tconst node = this.getNodeByName(c);\n\tconst children = this.adjList[node.name];\n\tconst operator = node.nodeType;\n\tconst value = node.value;\n\tconst RHS = operator === 'prop' && children.length > 0;\n\tconst left = this.getNodeByName(children[0]);\n\tconst right = this.getNodeByName(children[1]);\n\t\t\t\n\t// return true if the node already has a value\n\tif ( value !== null ) return true;\n\n\t// different tests for different operators, obviously\n\n\t// RHS\n\tif ( RHS ) {\n\t    node.value = left.value;\n\t    return true;\n\t}\n\t\n\t// NOT NODE\n\tif ( operator === 'not' ) {\n\t    if ( left.value === true ) {\n\t\tnode.value = false;\n\t\treturn true;\n\t    }\n\t    if ( left.value === false ) {\n\t\tnode.value = true;\n\t\treturn true;\n\t    }\n\t}\n\n\t// OR NODE\n\tif ( operator === 'or' ) {\n\t    node.value = left.value || right.value;\n\t    return true;\n\t}\n\n\t// AND NODE\n\tif ( operator === 'and' ) {\n\t    node.value = left.value && right.value;\n\t    return true;\n\t}\n\t\n\treturn false;\n\n    } // end _accept\n}\n\nexport class Node {\n    constructor( {name = null, nodeType = 'prop', value = null, nodeNames = []} = {})  {\n\t// let {name, nodeType, value, nodeNames} = args;\n\n\tthis.name = {name: name, nodeType: nodeType, takenNames: nodeNames};\n\tthis.nodeType = nodeType;\n\tthis.value = value;\n    }\n\n    // has to be a props object with {name: <name>, nodeType: <nodeType>, takenNames: <names \n    // that are not available>}\n    set name( {name = null, nodeType = null, takenNames = [] } = {} ) {\n\n\t// throw if name is already in the graph\n\tif ( takenNames && takenNames.includes(name) ) throw new Error( \" node name has already been used in this graph\");\n\t// generate a unique name if a unique name isn't provided\n\tif ( name  ) this._name = name;\n\telse {\n\t    this._name = _uniqueName(nodeType, takenNames);\n\t}\n    }\n\n    get name() {\n\treturn this._name;\n    }\n    \n    set nodeType(nodeType) {\n\t// enforce use one of the permissible nodeTypes (defaults to 'prop' when no args are provided)\n\tconst nodeTypes = ['prop', 'and', 'or', 'not'];\n\tif ( nodeTypes.includes(nodeType) ) \n\t    this._nodeType = nodeType;\n\telse if ( typeof nodeType !== 'undefined' ) \n\t    throw new Error(`nodeType must be one of ${nodeTypes}`);\n\telse this._nodeType = 'prop';\n    }\n\n    get nodeType() {\n\treturn this._nodeType;\n    }\n\n    // enforces use of set valueTypes, defaults to 'prop' (proposition)\n    set value(value) {\n\tconst valueTypes = [ true, false ];\n\tif ( valueTypes.includes(value) )\n\t    this._value = value;\n\telse if ( value !== null && typeof value !== 'undefined' && !valueTypes.includes(value) ) {\n\t    throw new Error(`value must be one of ${valueTypes}`);\n\t} else this._value = null;\n    }\n\n    get value() {\n\treturn this._value;\n    }\n}\n\nconst _uniqueName = ( nodeType, takenNames ) => {\n    let proposedName = _defaultName( nodeType );\n    if ( typeof takenNames === 'undefined' || takenNames.length < 1 ) return proposedName;\n    else if ( proposedName in takenNames ) _uniqueName( takenNames );\n    else return proposedName;\n};\n\nconst _defaultName = ( nodeType ) => {\n    // get a random char number between 65 to 122\n    // thx to https://stats.stackexchange.com/questions/281162/scale-a-number-between-a-range\n    let randomWordLen = 10;\n    let charNum = (e) => {\n\tconst rMin = 0, rMax = 1, tMin = 97, tMax = 122; // 97 to 122 is 'a' to 'z'\n\treturn String.fromCharCode( parseInt( ((e - rMin)/(rMax - rMin)) * (tMax - tMin) + tMin ) );\n    };\n    var name = '';\n    for(let i=0; i < randomWordLen; i++) {\n\tname += charNum(Math.random());\n    }\n\n    name = nodeType + '_' + name;\n\n    return name;\n};\n"],"file":"graph.js"}