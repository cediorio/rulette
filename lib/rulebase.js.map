{"version":3,"sources":["../src/rulebase.js"],"names":["ParseError","Error","constructor","message","name","RuleBase","createRuleTree","ast","graph","parent","_parseASTNode","testIdentifier","node","type","processBinary","left","right","root","createNode","nodeType","operator","addEdge","newLeftNode","newRightNode","e","DuplicateNameError","processNotOperator","notNode","argument","notOperandNode","rhs","lhs","logging","getNodeByName","parseRule","rule","jsep","addUnaryOp","addBinaryOp","err"],"mappings":"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","sourcesContent":["/** Define classes for RuleBase **/\n\nimport { Graph, Node, DuplicateNameError } from './graph';\nimport jsep from 'jsep';\n\nclass ParseError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ParseError\";\n  }\n}\n\nexport class RuleBase {\n\n    static createRuleTree( ast, graph ) {\n\t// debugger;\n\tif ( !graph ) throw new Error( \"createRuleTree requires a graph object as its second parameter.\");\n\tlet parent = null;\n\tthis._parseASTNode( ast, graph, parent );\n\treturn graph;\n    }\n\n    static _parseASTNode( ast, graph, parent ) {\n\t// check to see if the type is 'Identifier' in which\n\t// case it's a variable name and we can create a\n\t// prop(osition) node for it\n\tconst testIdentifier = ( node ) => { return ( node && node.type === 'Identifier' ) ? true : false; };\n\tconst processBinary = ( ) => {\n\t    const left = ast.left;\n\t    const right = ast.right;\n\t    // process the operator itself (the root of this iteration)\n\t    const root = graph.createNode( { nodeType: ast.operator } );\n\t    graph.addEdge( parent, root.name );\n\n\t    let newLeftNode, newRightNode;\n\t    // process the left side\n\t    \n\t    // begin by testing if the node is of type 'Identifier',\n\t    // in which case it corresponds to a fact and should be\n\t    // added as a 'prop' node\n\t    if ( testIdentifier( left ) ) {\n\t\t// only add a new node if the name is not already in the list\n\t\t// if it is in the list, add an edge from this rule to the\n\t\t// pre-existing Node with the same name\n\t\ttry {\n\t\t    newLeftNode = graph.createNode( { name: left.name, nodeType: 'prop' } );\n\t\t    graph.addEdge( root.name, newLeftNode.name );\n\t\t} catch (e) {\n\t\t    if ( e instanceof DuplicateNameError )\n\t\t\tgraph.addEdge( root.name, left.name );\n\t\t}\n\t    } else this._parseASTNode( left, graph, root.name );\n\n\t    // process the right side\n\t    if ( testIdentifier( right ) ) {\n\t\t// same process as the left side above\n\t\ttry {\n\t\t    newRightNode = graph.createNode( { name: right.name, nodeType: 'prop' } );\n\t\t    graph.addEdge( root.name, newRightNode.name );\n\t\t} catch (e) {\n\t\t    if ( e instanceof DuplicateNameError )\n\t\t\tgraph.addEdge( root.name, right.name );\n\t\t}\n\t    } else this._parseASTNode( right, graph, root.name );\n\n\t    return root;\n\t};\n\t\n\tconst processNotOperator = () => {\n\t    const notNode = graph.createNode( { nodeType: 'not' } );\n\t    graph.addEdge( parent, notNode.name );\n\t    \n\t    if ( ast.argument.type === 'Identifier' ) {\n\t\ttry {\n\t\t    const notOperandNode = graph.createNode( { name: ast.argument.name, nodeType: 'prop' });\n\t\t    graph.addEdge( notNode.name, notOperandNode.name );\n\t\t} catch (e) {\n\t\t    if ( e instanceof DuplicateNameError )\n\t\t\tgraph.addEdge( notNode.name, ast.argument.name );\n\t\t}\n\t    } else this._parseASTNode( ast.argument, graph, notNode.name );\n\n\t    return notNode;\n\t};\n\t\n\tswitch ( ast.type ) {\n\tcase 'BinaryExpression':\n\t    switch ( ast.operator ) {\n\t    case 'then':\n\t\tlet rhs;\n\t\tlet lhs;\n\t\tif ( ast.right &&  ast.right.type === 'Identifier' ) {\n\t\t    try {\n\t\t\trhs = graph.createNode( {name: ast.right.name, nodeType: 'prop' } );\n\t\t    } catch (e) {\n\t\t\tif ( e instanceof DuplicateNameError ) {\n\t\t\t    graph.logging( e.message );\n\t\t\t    rhs = graph.getNodeByName( ast.right.name );\n\t\t\t} else {\n\t\t\t    throw e;\n\t\t\t}\n\t\t    }\n\t\t    // if the left side is just an 'Identifier' (i.e., no further logic)\n\t\t    // then we don't need further parsing\n\t\t    if ( ast.left.type !== 'Identifier' )\n\t\t\tlhs = this._parseASTNode(ast.left, graph, rhs.name);\n\t\t    else { // we do have a Node whose type is 'Identifier'\n\t\t\tlhs = graph.getNodeByName(ast.left.name);\n\t\t\t// if the previous call didn't find the node in the graph\n\t\t\t// then create it\n\t\t\tif ( typeof lhs === 'undefined' )\n\t\t\t    lhs = graph.createNode( {name: ast.left.name, nodeType: 'prop'} );\n\t\t\t// and finally add it to adjacency list\n\t\t\tgraph.addEdge( rhs.name, lhs.name );\n\n\t\t    }\n\n\t\t} else throw new Error( `There was a problem with the form of the AST provided: the RHS was not of type 'Identifier'`);\n\t\tbreak;\n\t    case 'and':\n\t    case 'or':\n\t\treturn processBinary();\n\t\tbreak;\n\t    default:\n\t\tthrow new ParseError(`_parseASTNode could not parse the BinaryExpression with the following properties:\n\t\t\t\t\toperator: ${ast.operator}\n\t\t\t\t\t\n\t\t\t\t`);\n\t    }\n\t    break;\n\tcase 'UnaryExpression':\n\t    switch( ast.operator) {\n\t    case 'not':\n\t\treturn processNotOperator();\n\t\tbreak;\n\t    default:\n\t\tthrow new ParseError(`_parseASTNode could not parse the UnaryExpression that had a ${ast.operator} operator`);\n\t    }\n\t    break;\n\tdefault:\n\t    throw new ParseError(`_parseASTNode could not parse the ast.type - parameters passed in were:\n\t\t\t\t\tast.type:\t${ast.type}\n\t\t\t\t\tast.operator:\t${ast.operator}`);\n\t}\n    }\n    \n    static parseRule ( rule ) {\n\n\t// add custom operators\n\n\tjsep.addUnaryOp('not', 10);\n\tjsep.addBinaryOp('and', 10);\n\tjsep.addBinaryOp('or', 10);\n\tjsep.addBinaryOp('then', 1);\n\n\ttry {\n\t    return jsep(rule);\n\t} catch (err) {\n\t    throw new ParseError(`jsep encountered the following error parsing the supplied rule text:\n\t\tRULE TEXT:\t\t${rule}\n\t\tJSEP ERROR:\t\t${err}`);\n\t}\n    }\n}\n\n"],"file":"rulebase.js"}