{"version":3,"sources":["../src/ruleEngine.js"],"names":["ParseError","Error","constructor","message","name","RuleBase","createRuleTree","ast","graph","parent","_parseASTNode","testIdentifier","node","type","processBinary","left","right","root","createNode","nodeType","operator","addEdge","newLeftNode","newRightNode","processNotOperator","notNode","argument","notOperandNode","parseRule","rule","jsep","addUnaryOp","addBinaryOp","err","fire","kb","rules","setAgenda","facts","ruleResultsJSON","openFacts","closedFacts","factEvalStr","buildFactEvalStr","i","length","resultText","lhs","lhs_facts","tokenize","ruleEvalStr","result","vm","runInContext","sandbox","trueDisplayValue","rhs","value","falseDisplayValue","push","topic","source","map","fact","getFactStatus","support_description","factDescription","agenda","forEach","inAgenda","tokens","indexOf","unshift"],"mappings":"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","sourcesContent":["/** Define classes for RuleBase **/\n\nimport { Graph, Node } from './graph';\nimport jsep from 'jsep';\n\nclass ParseError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ParseError\";\n  }\n}\n\nexport class RuleBase {\n\n    static createRuleTree( ast, graph ) {\n\t// debugger;\n\tif ( !graph ) throw new Error( \"createRuleTree requires a graph object as its second parameter.\");\n\tlet parent = null;\n\tthis._parseASTNode( ast, graph, parent );\n\treturn graph;\n    }\n\n    static _parseASTNode( ast, graph, parent ) {\n\t\n\t// check to see if the type is 'Identifier' in which\n\t// case it's a variable name and we can create a\n\t// prop(osition) node for it\n\tconst testIdentifier = ( node ) => { return ( node && node.type === 'Identifier' ) ? true : false; };\n\tconst processBinary = ( ) => {\n\t    const left = ast.left;\n\t    const right = ast.right;\n\t    // process the operator itself (the root of this iteration)\n\t    const root = graph.createNode( { nodeType: ast.operator } );\n\t    graph.addEdge( parent, root.name );\n\n\t    let newLeftNode, newRightNode;\n\t    // process the left side\n\t    \n\t    if ( testIdentifier( left ) ) {\n\t\tnewLeftNode = graph.createNode( { name: left.name, nodeType: 'prop' } );\n\t\tgraph.addEdge( root.name, newLeftNode.name ); \n\t    } else this._parseASTNode( right, graph, root.name );\n\n\t    // process the right side\n\t    if ( testIdentifier( right ) ) {\n\t\tnewRightNode = graph.createNode( { name: right.name, nodeType: 'prop' } );\n\t\tgraph.addEdge( root.name, newRightNode.name ); \n\t    } else this._parseASTNode( right, graph, root.name );\n\t};\n\tconst processNotOperator = () => {\n\t    const notNode = graph.createNode( { nodeType: 'not' } );\n\t    graph.addEdge( parent, notNode.name );\n\t    \n\t    if ( ast.argument.type === 'Identifier' ) {\n\t\tconst notOperandNode = graph.createNode( { name: ast.argument.name, nodeType: 'prop' });\n\t\tgraph.addEdge( notNode.name, notOperandNode.name );\n\t    } else this._parseASTNode( ast.argument, graph, notNode.name );\n\t};\n\t\n\tswitch ( ast.type ) {\n\tcase 'BinaryExpression':\n\t    switch ( ast.operator ) {\n\t    case 'then':\n\t\tif ( ast.right &&  ast.right.type === 'Identifier' ) {\n\t\t    const parent = graph.createNode( {name: ast.right.name, nodeType: 'prop' } );\n\t\t    this._parseASTNode(ast.left, graph, parent.name);\n\t\t}\n\t\tbreak;\n\t    case 'and':\n\t    case 'or':\n\t\tprocessBinary();\n\t\tbreak;\n\t    default:\n\t\tthrow new ParseError(`_parseASTNode could not parse the BinaryExpression with the following properties:\n\t\t\t\t\toperator: ${ast.operator}\n\t\t\t\t\t\n\t\t\t\t`);\n\t    }\n\t    break;\n\tcase 'UnaryExpression':\n\t    switch( ast.operator) {\n\t    case 'not':\n\t\tprocessNotOperator();\n\t\tbreak;\n\t    default:\n\t\tthrow new ParseError(`_parseASTNode could not parse the UnaryExpression that had a ${ast.operator} operator`);\n\t    }\n\t    break;\n\tdefault:\n\t    throw new ParseError(`_parseASTNode could not parse the ast.type - parameters passed in were:\n\t\t\t\t\tast.type:\t${ast.type}\n\t\t\t\t\tast.operator:\t${ast.operator}`);\n\t}\n    }\n    \n    static parseRule ( rule ) {\n\n\t// add custom operators\n\n\tjsep.addUnaryOp('not', 10);\n\tjsep.addBinaryOp('and', 10);\n\tjsep.addBinaryOp('or', 10);\n\tjsep.addBinaryOp('then', 1);\n\n\ttry {\n\t    return jsep(rule);\n\t} catch (err) {\n\t    throw new ParseError(`jsep encountered the following error parsing the supplied rule text:\n\t\tRULE TEXT:\t\t${rule}\n\t\tJSEP ERROR:\t\t${err}`);\n\t}\n    }\n}\n\n\nexport const fire = (kb) => {\n  //set up a sandbox context for evaluation\n\n  var rules = setAgenda(kb.rules);\n  var facts = kb.facts;\n  var ruleResultsJSON = []; // full report on results of Rule evaluation\n  var openFacts = []; // Facts which have no answers yet\n  var closedFacts = []; // Facts which have been answered\n  var factEvalStr = buildFactEvalStr(facts);\n  // evaluate the rules\n  for (let i = 0; i < rules.length; i++) {\n    let resultText = \"\";\n    if (rules[i].lhs === \"\") continue; // skip if there is no rule on this line\n    let lhs_facts = tokenize(rules[i].lhs);\n    let ruleEvalStr = rules[i].lhs;\n    let result = vm.runInContext(factEvalStr + \"\\n\" + ruleEvalStr, sandbox);\n\n    if (result) {\n      resultText = rules[i].trueDisplayValue;\n      vm.runInContext(\"var \" + rules[i].rhs + \" = true;\", sandbox); // assert the right-hand of the rule\n      rules[i].value = true;\n    } else {\n      resultText = rules[i].falseDisplayValue;\n      vm.runInContext(\"var \" + rules[i].rhs + \" = false;\", sandbox); // deny the right-hand of the rule\n      rules[i].value = false;\n    }\n    // console.log('this topic is: ' + rules[i].topic);\n    ruleResultsJSON.push({\n      name: rules[i].name,\n      lhs: rules[i].lhs,\n      rhs: rules[i].rhs,\n      value: rules[i].value,\n      topic: rules[i].topic,\n      source: rules[i].source,\n      result: resultText,\n      facts: lhs_facts.map(function(i) {\n        var fact = getFactStatus(i, kb);\n        // var support_desc = !!fact.factDescription ? fact.factDescription : \"No further support provided\";\n        return {\n          name: fact.name,\n          value: fact.value,\n          support_description: fact.factDescription\n        };\n      })\n    });\n  }\n  // console.log(resultsJSON);\n  return {\n    ruleResultsJSON,\n    openFacts,\n    closedFacts\n  };\n};\n\n\nexport const setAgenda = (rules) => {\n  var agenda = [];\n  // get all the rule names\n  // var rule_names = rules.map(function(rule) {\n  //   return rule.name;\n  // });\n\n  rules.forEach(function(rule) {\n    var inAgenda = false; // flag to mark presence of rule in agenda\n    for (let i = 0; i < agenda.length; i++) {\n      // tokenize each lhs and check to see if the current rule.rhs is in it\n      var tokens = tokenize(agenda[i].lhs);\n      // if it is in the agenda, put it at the front of the agenda and bail\n      if (tokens.indexOf(rule.rhs) > -1) {\n        inAgenda = true;\n        agenda.unshift(rule);\n        break;\n      }\n    }\n    // if the previous for loop didn't find the current rule.rhs in the agenda,\n    // push it onto the end of the agenda\n    if (!inAgenda) agenda.push(rule);\n  });\n\n  return agenda;\n};\n\n\n"],"file":"ruleEngine.js"}