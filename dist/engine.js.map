{"version":3,"sources":["../src/engine.js"],"names":["RuleEngine","constructor","rules","facts","dev","results","agenda","debug","msg","console","log","eeval","expr","Function","parseFacts","parseRules","Object","entries","forEach","name","rule","parseRule","Error","hasOwnProperty","lhs","replace","setAgenda","evalRules","evalRule","JSON","parse","stringify","result","eval_log","regex_find_assignments","assignments","match","i","regex_parse_assignment","lexed","exec","key","val","includes","fact_value","value","stop_words","regex_find_unaries","unaries","rhs","fire"],"mappings":"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","sourcesContent":["export default\n\nclass RuleEngine {\n    constructor(rules, facts, dev=false){\n        this.dev = dev;\n        this.rules = rules;\n        this.facts = facts;\n        this.results = {};\n        this.agenda = []\n    }\n\n    debug(msg) {\n        this.dev ? console.log(msg) : null;\n    }\n\n    eeval(expr) { \n        return Function('\"use strict\";return (' + expr + ')')()\n    }\n\n    parseFacts(){\n        this.debug(\"running parseFacts...\");\n        // presently have nothing to do here, but may need to\n        // parse facts as the scripting language develops\n    }\n\n    parseRules(){\n        // we loop through the rules, substituting\n        // legal JS boolean operations for \"and\", \"or\" and \"not\"\n        this.debug(`running parseRules...`);\n        Object.entries(this.rules).forEach( ([name, rule]) => {\n            this.parseRule(name, rule);\n        });\n    }\n\n    parseRule(name,rule) {\n        if(!name) {\n            throw new Error(\"No name specified for rule\");\n            return false;\n        } else if(!rule.hasOwnProperty('lhs')) {\n            throw new Error(\"No left-hand side specified for rule\");\n            return false;\n        } else if(!rule.hasOwnProperty('rhs')) {\n            throw new Error(\"No right-hand side specified for rule\");\n            return false;\n        }\n        rule.lhs = rule.lhs.replace( / +and +/g, \" && \");\n        rule.lhs = rule.lhs.replace( / +or +/g, \" || \");\n        rule.lhs = rule.lhs.replace( / +not +/g, \" !\");\n        // add the name as a property for results processing\n        rule.name = name;\n        return rule;\n    }\n\n    setAgenda() {\n        this.debug(`setting agenda for rule firing...`);\n    }\n\n    evalRules(){\n        this.debug(`running evalRules...`);\n        Object.entries(this.rules).forEach( ([name, rule]) => {\n            // use JSON methods to clone a new object, so you\n            // don't send a reference to this.rules's member\n            this.evalRule(JSON.parse(JSON.stringify(rule)));\n        });\n    }\n    /*\n        evalRule can accept a rule and can also take an optional facts\n        object. If there is no facts object, then the class facts \n        object will be searched.\n    */\n    evalRule(rule, facts=null){\n        this.debug(\"========================\\nrunning evalRule...\");\n        let result = null;\n        let eval_log = []; // a list of the results of evaluation to use in reasons\n        // first must parse for any rule clauses that have assignments\n        // and evaluate them based on their corresponding fact value\n        this.debug(`parsing the rule <${rule.name}> as:\n              ${rule.lhs}`);\n        let regex_find_assignments = /(\\w+ *(!=|=) *(\\w+|['\"]*[\\w*|\\s]*)['\"]*)/g; // /(\\w+ *(!=|=) *['\"]*(\\w+|true|false|null)['\"]*)/g;\n        let assignments = rule.lhs.match(regex_find_assignments);\n        if(assignments){\n            for(let i of assignments){\n                let regex_parse_assignment = /(\\w+) *(!=|=) *(\\w+|['\"]*[\\w*|\\s]*['\"]*)/g;\n                let lexed = regex_parse_assignment.exec(i);\n                if(lexed){\n                    let key = lexed[1];\n                    let val = lexed[3];\n                    // need to convert any js truth values that may \n                    // have been provided as strings\n                    if (val === 'true') { val = true; }\n                    else if (val === 'false') { val = false; }\n                    else if (val.includes('none', 'None','null', 'Null')) { val = null; }\n                    \n                    // evaluate the rule's required value against the\n                    // fact value\n                    // let value = val === this.facts[key].value ? true : false; \n                    let fact_value = facts ? facts[key] : this.facts[key].value;\n                    let value = val === fact_value; \n                    // now replace the var from the clause with its\n                    // truth value\n                    rule.lhs = rule.lhs.replace(i, value);\n                }\n            }\n        }\n\n        // unary tokens are simply replaced with their truth value\n        let stop_words = ['true', 'false', 'and', 'or', 'not'];\n        let regex_find_unaries = /(\\w+)/g\n        let unaries = rule.lhs.match(regex_find_unaries);\n        if(unaries){\n            for(let i of unaries){\n                if(!stop_words.includes(i)){\n                    /* let value = this.facts[i].value;\n                    rule.lhs = rule.lhs.replace(i, value); */\n                    let value = facts ? facts[i] : this.facts[i].value;\n                    rule.lhs = rule.lhs.replace(i, value);\n                }\n            }\n        }\n\n        this.results[rule.name] = this.eeval(rule.lhs);\n\n        this.debug(`New result added after rule eval:\n              rule.name: ${rule.name}\n              rule.lhs: ${rule.lhs}\n              rule.rhs: ${rule.rhs}`);\n\n        return rule;\n    }\n\n    fire(){\n        this.parseFacts();\n        this.parseRules();\n        this.evalRules();\n        return \"fired!\";\n    }\n}"],"file":"engine.js"}