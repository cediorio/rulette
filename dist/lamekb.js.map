{"version":3,"sources":["../src/lamekb.js"],"names":["dev","debug","msg","console","log","facts","rules","results","eeval","expr","Function","RuleEngine","constructor","parseFacts","evalRules","Object","keys","forEach","key","rule","lhs","replace","evalRule","JSON","parse","stringify","result","eval_log","name","regex_find_assignments","assignments","match","i","regex_parse_assignment","lexed","exec","val","value","stop_words","regex_find_unaries","unaries","includes","rhs","fire"],"mappings":"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","sourcesContent":["export {facts, rules, RuleEngine};\nvar dev = true;\nvar debug = (msg) => dev ? console.log(msg) : null;\nvar facts = {\n    \"corporation_type\":\n    {\n        \"question\": \"What type of corporation is the employer?\",\n        \"values\": [\"CCPC\", \"private corporation\", \"public corporation\"],\n        \"value\": \"CCPC\"\n    },\n    \"agmt_to_issue_shares\":\n    {\n        \"question\": \"Is there a legally binding agreement to issue shares?\",\n        \"values\": [\"true\", \"false\"],\n        \"value\": \"true\"\n    },\n    \"ee_AL\":\n    {\n        \"question\": \"Immediately after the agreement was made, was the employee dealing at arm's length with the employer and/or the corporation or mutual fund that agreed to issue securities?\",\n        \"values\": [\"true\", \"false\"],\n        \"value\": \"true\"\n    },\n    \"prescribed_shares\":\n    {\n        \"question\": \"Did the shares qualify as prescribed shares at the time they were issued (or would have been issued if the taxpayer disposed of their options)?\", \n        \"values\": [\"true\", \"false\"],\n        \"value\": \"true\"\n    },\n    // testing values\n    \"aa\":\n    {\n        \"value\": \"touchy feely\"\n    },\n    \"b1\":\n    {\n        \"value\": \"fine with me\"\n    },\n    \"c1\":\n    {\n        \"value\": \"true\"\n    }\n\n};\n\nvar rules = {\n    \"s7_agmt\":\n    {\n        \"lhs\": \"agmt_to_issue_shares\",\n        \"rhs\": \"s7_agmt\"\n    },\n    \"CCPC_deferral\":\n    {\n        \"lhs\": \"corporation_type='CCPC' and ee_AL\",\n        \"rhs\": \"CCPC_deferral\"\n    },\n    \"ee_option_deduction\":\n    {\n        \"lhs\": \"ee_AL and agmt_to_issue_shares and prescribed_shares\",\n        \"rhs\": \"p110_1_d_deduction\"        \n    },\n    \"harsh_test\":\n    {\n        \"lhs\": \"(aa = 'touchy feely' or b1 = 'fine with me') and c1\",\n        \"rhs\": \"harsh_test_passed\"\n    }\n};\n\nvar results = {};\n\nvar eeval = expr => Function('\"use strict\";return (' + expr + ')')();\n// function eeval(expr){ eval(expr); }\n\nclass RuleEngine {\n    constructor(rules, facts){\n        this.rules = rules;\n        this.facts = facts;\n        this.results = {};\n    }\n\n    parseFacts(){\n        debug(\"running parseFacts...\");\n        // presently have nothing to do here, but may need to\n        // parse facts as the scripting language develops\n    }\n    \n    evalRules(){\n        // we loop through the rules, first substituting\n        // legal JS boolean operations for \"and\", \"or\" and \"not\"\n        // and then evaluating the truthiness via evalRule\n        debug(`running evalRules...`);\n        Object.keys(this.rules).forEach( key => {\n\t    let rule = this.rules[key];\n\t    rule['name'] = key;\n\t    rule.lhs = rule.lhs.replace( / +and +/g, \" && \");\n\t    rule.lhs = rule.lhs.replace( / +or +/g, \" || \");\n\t    rule.lhs = rule.lhs.replace( / +not +/g, \" ! \");\n\t    \n\t    // use JSON methods to clone a new object, so you\n\t    // don't send a reference to this.rules's member\n\t    this.evalRule(JSON.parse(JSON.stringify(rule)));\n        });\n    }\n\n    evalRule(rule){\n        debug(\"========================\\nrunning evalRule...\");\n        let result = null;\n        let eval_log = []; // a list of the results of evaluation to use in reasons\n        // first must parse for any rule clauses that have assignments\n        // and evaluate them based on their corresponding fact value\n        debug(`parsing the rule <${rule.name}> as:\n              ${rule.lhs}`);\n        let regex_find_assignments = /(\\w+ *= *[\"'][\\w ]*[\"'])/g;\n        let assignments = rule.lhs.match(regex_find_assignments);\n        if(assignments){\n\t    for(let i of assignments){\n                let regex_parse_assignment = /(\\w+) *= *[\"']([\\w ]*)[\"']/g;\n                let lexed = regex_parse_assignment.exec(i);\n                if(lexed){\n\t\t    let key = lexed[1];\n\t\t    let val = lexed[2];\n\t\t    // evaluate the rule's required value against the\n\t\t    // fact value\n\t\t    let value = val === this.facts[key].value ? true : false;\n\n\t\t    // now replace the var from the clause with its\n\t\t    // truth value\n\t\t    rule.lhs = rule.lhs.replace(i, value);\n                }\n\t    }\n        }\n\n        // unary tokens are simply replaced with their truth value\n        let stop_words = ['true', 'false', 'and', 'or', 'not'];\n        let regex_find_unaries = /(\\w+)/g\n        let unaries = rule.lhs.match(regex_find_unaries);\n        if(unaries){\n\t    for(let i of unaries){\n                if(!stop_words.includes(i)){\n\t\t    let value = this.facts[i].value;\n\t\t    rule.lhs = rule.lhs.replace(i, value);\n                }\n\t    }\n        }\n        this.results[rule.rhs] = {\n\t    'value': eeval(rule.lhs)\n        };\n\n        debug(`New result added after rule eval:\n              ${rule.rhs} -> ${this.results[rule.rhs].value}`);\n    }\n    fire(){\n        this.parseFacts();\n        this.evalRules();\n        return \"fired!\";\n    }\n}\n"],"file":"lamekb.js"}